<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Race App Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
    }

    /* Custom alert styles */
    .custom-alert {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #22c55e;
      color: white;
      padding: 1.5rem 2.5rem;
      border-radius: 0.5rem;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
      max-width: 24rem;
      width: 100%;
    }

    .spoiler-content {
      transition: all 0.5s ease-in-out;
    }

    /* Style for the toggle switch */
    input:checked~.dot {
      transform: translateX(100%);
      background-color: #22c55e;
      /* Green when on */
    }

    input:checked~.block {
      background-color: #374151;
      /* Darker gray when on */
    }
  </style>
</head>

<body
  class="min-h-screen bg-gradient-to-br from-gray-900 to-black flex items-center justify-center md:p-4 font-inter text-gray-200">

  <div class="w-full max-w-4xl mx-auto p-4 sm:p-6 md:p-8 bg-zinc-900 md:rounded-xl shadow-2xl border-t-4 border-blue-600">
    <div class="flex justify-between items-center mb-8 pb-4 border-b border-gray-700">
      <div class="p-3 rounded-lg bg-gray-800 border border-gray-700 shadow-md">
        <span class="font-extrabold text-2xl text-blue-500 tracking-wider">RACE.APP</span>
      </div>
      <div class="flex items-center gap-4">
        <button id="showSavedDetailsBtn"
          class="p-3 rounded-lg bg-gray-800 border border-gray-700 shadow-md cursor-pointer hover:bg-gray-700 transition duration-300">
          <span class="font-bold text-lg text-amber-400">SAVED (<span id="savedCount">0</span>)</span>
        </button>
      </div>
    </div>

    <div class="mb-10 text-center md:text-left">
      <p class="text-2xl text-gray-100">
        Next Race: <span id="nextRaceName" class="text-orange-500 font-bold"></span> In
        <span id="countdownDays" class="text-red-500 font-extrabold">0</span> days,
        <span id="countdownHours" class="text-red-500 font-extrabold">0</span> hours,
        <span class="text-red-500 font-extrabold">0</span> minutes
      </p>
      <p class="text-lg text-gray-300">
        Circuit: <span id="nextRaceCircuit"></span>
      </p>
    </div>

    <div id="mainContent" class="mb-10 space-y-4">
      <div class="bg-gray-800 p-4 rounded-lg shadow-md border border-gray-700">
        <label for="raceNameSelect" class="block text-lg font-bold text-blue-400 mb-2">Race Name</label>
        <select id="raceNameSelect"
          class="w-full bg-gray-900 text-gray-200 border border-gray-600 rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200">
          <option value="" disabled selected>Select a Race Name</option>
        </select>
      </div>

      <div id="teamDropdownContainer" class="bg-gray-800 p-4 rounded-lg shadow-md border border-gray-700 hidden">
        <label for="teamNamesSelect" class="block text-lg font-bold text-blue-400 mb-2">Team Name</label>
        <select id="teamNamesSelect"
          class="w-full bg-gray-900 text-gray-200 border border-gray-600 rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200">
          <option value="" disabled selected>Select a Team Name</option>
        </select>
      </div>

      <div id="upgradesDropdownContainer" class="bg-gray-800 p-4 rounded-lg shadow-md border border-gray-700 hidden">
        <label for="upgradesNameSelect" class="block text-lg font-bold text-blue-400 mb-2">Upgrade Name</label>
        <select id="upgradesNameSelect"
          class="w-full bg-gray-900 text-gray-200 border border-gray-600 rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-blue-500 transition duration-200">
          <option value="" disabled selected>Select an Upgrade</option>
        </select>
      </div>
    </div>

    <div id="detailsCard" class="flex-col md:flex-row gap-8 mb-8 hidden">
      <div class="relative flex-1 bg-gray-800 border border-gray-700 p-4 md:p-8 rounded-xl shadow-lg">
        <h3 class="font-bold text-2xl mb-4 text-white">Details</h3>

        <p class="mb-3 text-gray-300"><span class="font-semibold text-white">Part Name:</span> <span
            id="detailPartName"></span></p>
        <p class="mb-3 text-gray-300"><span class="font-semibold text-white">Reason for upgrade:</span> <span
            id="detailPrimaryReason"></span></p>
        <p class="mb-3 text-gray-300"><span class="font-semibold text-white">Geometric Differences:</span> <span
            id="detailGeometricDifferences"></span></p>
        <p class="text-gray-300"><span class="font-semibold text-white">Description:</span> <span
            id="detailDescription"></span></p>

        <div id="spoilerSectionInCard" class="hidden mt-6 pt-6 border-t border-gray-700">
          <div class="flex items-center justify-between">
            <h3 class="text-lg font-bold text-red-400">Spoilers</h3>
            <label for="spoilerToggle" class="flex items-center cursor-pointer">
              <span class="mr-3 text-gray-300">Show Results</span>
              <div class="relative">
                <input type="checkbox" id="spoilerToggle" class="sr-only">
                <div class="block bg-gray-600 w-14 h-8 rounded-full"></div>
                <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition"></div>
              </div>
            </label>
          </div>
          <div id="spoilerContent" class="spoiler-content max-h-0 overflow-hidden mt-4">
            <div id="spoilerResults" class="text-gray-300 space-y-3">
              <p>Toggle on to see results.</p>
            </div>
            <div class="my-8 pt-6 border-t border-gray-700"></div>
            <div class="session-container">
                </div>
          </div>
        </div>

        <button id="saveDetailBtn"
          class="mt-8 px-8 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition duration-300 shadow-xl font-bold tracking-wide">
          Save Detail Card <span class="ml-2">&#10003;</span>
        </button>
      </div>
    </div>

    <div id="savedDetailsView"
      class="bg-zinc-800 border border-zinc-700 p-8 rounded-xl shadow-2xl w-full max-w-4xl mx-auto hidden">
      <h3 class="font-bold text-2xl mb-6 text-white text-center">Your Saved Details</h3>
      <div id="savedDetailsList" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        </div>
      <button id="backToMainBtn"
        class="mt-8 px-8 py-3 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition duration-300 shadow-lg font-bold mx-auto block">
        Back to Main
      </button>
    </div>

    <div id="customAlert" class="custom-alert hidden">
      <p id="alertMessage" class="text-lg font-semibold"></p>
      <button id="closeAlertBtn"
        class="bg-green-700 hover:bg-green-800 text-white font-bold py-2 px-6 rounded-md transition duration-300">
        OK
      </button>
    </div>
  </div>

  <div id="graphModal" class="fixed inset-0 bg-black bg-opacity-75 z-50 hidden items-center justify-center p-4" style="display: none;">
    <div class="bg-zinc-800 rounded-xl shadow-2xl w-full max-w-6xl max-h-full overflow-y-auto p-6 relative">
      <button id="closeModalBtn" class="absolute top-2 right-4 text-gray-400 hover:text-white text-4xl font-bold">&times;</button>
      <div id="modalChartContainer">
        <canvas id="modalChartCanvas"></canvas>
      </div>
    </div>
  </div>


  <script>
    // Data Definitions with API mapping for 2025
    const raceSchedule = [
        { name: "Louis Vuitton Australian GP", circuit: "Melbourne Grand Prix Circuit", location: "Melbourne", raceDate: new Date("2025-03-16T12:00:00"), apiMeetingName: "Australian Grand Prix" },
        { name: "Heineken Chinese GP", circuit: "Shanghai International Circuit", location: "Shanghai", raceDate: new Date("2025-03-23T12:00:00"), apiMeetingName: "Chinese Grand Prix" },
        { name: "Lenovo Japanese GP", circuit: "Suzuka International Racing Course", location: "Suzuka", raceDate: new Date("2025-04-06T12:00:00"), apiMeetingName: "Japanese Grand Prix" },
        { name: "Gulf Air Bahrain GP", circuit: "Bahrain International Circuit", location: "Sakhir", raceDate: new Date("2025-04-13T12:00:00"), apiMeetingName: "Bahrain Grand Prix" },
        { name: "STC Saudi Arabian GP", circuit: "Jeddah Street Circuit", location: "Jeddah", raceDate: new Date("2025-04-20T12:00:00"), apiMeetingName: "Saudi Arabian Grand Prix" },
        { name: "Crypto.com Miami GP", circuit: "Miami International Autodrome", location: "Miami", raceDate: new Date("2025-05-04T12:00:00"), apiMeetingName: "Miami Grand Prix" },
        { name: "AWS Made in Italy Emilia Romagna GP", circuit: "Autodromo Enzo e Dino Ferrari", location: "Imola", raceDate: new Date("2025-05-18T12:00:00"), apiMeetingName: "Emilia Romagna Grand Prix" },
        { name: "Tag Heuer Monaco GP", circuit: "Circuit de Monaco", location: "Monaco", raceDate: new Date("2025-05-25T12:00:00"), apiMeetingName: "Monaco Grand Prix" },
        { name: "Aramco Spanish GP", circuit: "Circuit de Barcelona-Catalunya", location: "Barcelona", raceDate: new Date("2025-06-01T12:00:00"), apiMeetingName: "Spanish Grand Prix" },
        { name: "Pirelli Canadian GP", circuit: "Circuit Gilles-Villeneuve", location: "Montr√©al", raceDate: new Date("2025-06-15T12:00:00"), apiMeetingName: "Canadian Grand Prix" },
        { name: "MSC Cruises Austrian GP", circuit: "Red Bull Ring", location: "Spielberg", raceDate: new Date("2025-06-29T12:00:00"), apiMeetingName: "Austrian Grand Prix" },
        { name: "Qatar Airways British GP", circuit: "Silverstone Circuit", location: "Silverstone", raceDate: new Date("2025-07-06T12:00:00"), apiMeetingName: "British Grand Prix" },
        { name: "Mo√´t & Chandon Belgian GP", circuit: "Circuit de Spa-Francorchamps", location: "Spa-Francorchamps", raceDate: new Date("2025-07-27T09:00:00"), apiMeetingName: "Belgian Grand Prix" },
        { name: "Lenovo Hungarian GP", circuit: "Hungaroring", location: "Budapest", raceDate: new Date("2025-08-03T09:00:00"), apiMeetingName: "Hungarian Grand Prix" },
        { name: "Heineken Dutch GP", circuit: "Circuit Park Zandvoort", location: "Zandvoort", raceDate: new Date("2025-08-31T09:00:00"), apiMeetingName: "Dutch Grand Prix" },
        { name: "Pirelli Italian GP", circuit: "Autodromo Nazionale Monza", location: "Monza", raceDate: new Date("2025-09-07T09:00:00"), apiMeetingName: "Italian Grand Prix" },
        { name: "Qatar Airways Azerbaijan GP", circuit: "Baku City Circuit", location: "Baku", raceDate: new Date("2025-09-21T07:00:00"), apiMeetingName: "Azerbaijan Grand Prix" },
        { name: "Singapore Airlines Singapore GP", circuit: "Marina Bay Street Circuit", location: "Singapore", raceDate: new Date("2025-10-05T08:00:00"), apiMeetingName: "Singapore Grand Prix" },
        { name: "MSC Cruises United States GP", circuit: "Circuit of the Americas", location: "Austin", raceDate: new Date("2025-10-19T15:00:00"), apiMeetingName: "United States Grand Prix" },
        { name: "Mexico City GP", circuit: "Autodromo Hermanos Rodriguez", location: "Mexico City", raceDate: new Date("2025-10-26T16:00:00"), apiMeetingName: "Mexico City Grand Prix" },
        { name: "MSC Cruises S√£o Paulo GP", circuit: "Autodromo Jose Carlos Pace", location: "S√£o Paulo", raceDate: new Date("2025-11-09T12:00:00"), apiMeetingName: "S√£o Paulo Grand Prix" },
        { name: "Heineken Las Vegas GP", circuit: "Las Vegas Street Circuit", location: "Las Vegas", raceDate: new Date("2025-11-22T23:00:00"), apiMeetingName: "Las Vegas Grand Prix" },
        { name: "Qatar Airways Qatar GP", circuit: "Losail International Circuit", location: "Lusail", raceDate: new Date("2025-11-30T11:00:00"), apiMeetingName: "Qatar Grand Prix" },
        { name: "Etihad Airways Abu Dhabi GP", circuit: "Yas Marina Circuit", location: "Yas Island", raceDate: new Date("2025-12-07T08:00:00"), apiMeetingName: "Abu Dhabi Grand Prix" },
    ];

    const upgradeData = [
      { "Year": 2025, "RaceName": "Qatar Airways British GP", "Constructor": "MCLAREN F1 TEAM", "UpdatedComponent": "Floor Body", "PrimaryReason": "Performance - Local Load", "GeometricDifferences": "Revised floor geometry", "Description": "The complete floor has been revised resulting in improved flow conditioning and a redistribution of suction to gain overall aerodynamic performance." },
      { "Year": 2025, "RaceName": "Qatar Airways British GP", "Constructor": "MCLAREN F1 TEAM", "UpdatedComponent": "Rear Corner", "PrimaryReason": "Performance - Flow Conditioning", "GeometricDifferences": "Revised Rear Corner Inlet", "Description": "Modification to Rear Brake Duct Inlet aiming at overall improvement in local flow conditioning for improved aerodynamic and brake cooling performance." },
      { "Year": 2025, "RaceName": "Qatar Airways British GP", "Constructor": "Red Bull Racing", "UpdatedComponent": "Floor Body", "PrimaryReason": "Performance - Local Load", "GeometricDifferences": "Re-profiled surfaces to supplement the changes to the fences", "Description": "Revised surfaces to improve pressure distribution over the length of the floor allowing more load to be extracted whilst maintaining adequate flow stability." },
    ];


    let savedDetailsList = []; // In-memory storage for saved details

    // DOM Elements
    const raceNameSelect = document.getElementById('raceNameSelect');
    const teamNamesSelect = document.getElementById('teamNamesSelect');
    const upgradesNameSelect = document.getElementById('upgradesNameSelect');
    const teamDropdownContainer = document.getElementById('teamDropdownContainer');
    const upgradesDropdownContainer = document.getElementById('upgradesDropdownContainer');
    const detailsCard = document.getElementById('detailsCard');
    const detailPartName = document.getElementById('detailPartName');
    const detailPrimaryReason = document.getElementById('detailPrimaryReason');
    const detailGeometricDifferences = document.getElementById('detailGeometricDifferences');
    const detailDescription = document.getElementById('detailDescription');
    const saveDetailBtn = document.getElementById('saveDetailBtn');
    const showSavedDetailsBtn = document.getElementById('showSavedDetailsBtn');
    const savedCountSpan = document.getElementById('savedCount');
    const savedDetailsView = document.getElementById('savedDetailsView');
    const savedDetailsListContainer = document.getElementById('savedDetailsList');
    const backToMainBtn = document.getElementById('backToMainBtn');
    const mainContent = document.getElementById('mainContent');
    const customAlert = document.getElementById('customAlert');
    const alertMessage = document.getElementById('alertMessage');
    const closeAlertBtn = document.getElementById('closeAlertBtn');

    // Spoiler Elements
    const spoilerSectionInCard = document.getElementById('spoilerSectionInCard');
    const spoilerToggle = document.getElementById('spoilerToggle');
    const spoilerContent = document.getElementById('spoilerContent');
    const spoilerResults = document.getElementById('spoilerResults');


    // --- Spoiler Feature Functions ---
    const API_BASE_URL = "https://api.openf1.org/v1";
    const YEAR = 2025; // Use 2025 data
    let sessionCache = {}; // Cache for session keys to reduce API calls

    async function getSession(location, sessionType) {
      const cacheKey = `${location}-${sessionType}-${YEAR}`;
      if (sessionCache[cacheKey]) {
        return sessionCache[cacheKey];
      }
      try {
        const resp = await fetch(`${API_BASE_URL}/sessions?year=${YEAR}&location=${location}&session_name=${sessionType}`);
        if (!resp.ok) throw new Error(`API error: ${resp.statusText}`);
        let sessions = await resp.json();

        if (sessions.length === 0) { // Fallback for circuit names
          const circuitResp = await fetch(`${API_BASE_URL}/sessions?year=${YEAR}&circuit_short_name=${location}&session_name=${sessionType}`);
          if (circuitResp.ok) sessions = await circuitResp.json();
        }

        if (sessions.length > 0) {
          sessions.sort((a, b) => new Date(b.date_start) - new Date(a.date_start));
          sessionCache[cacheKey] = sessions[0];
          return sessions[0];
        }
        return null;
      } catch (error) {
        console.error(`Error fetching ${sessionType} session for ${location}:`, error);
        return null;
      }
    }

    async function getDriverDetails(driverNumber) {
      try {
        const resp = await fetch(`${API_BASE_URL}/drivers?driver_number=${driverNumber}&session_key=latest`);
        if (!resp.ok) return { name: 'Unknown Driver' };
        const data = await resp.json();
        return data[0] ? { name: data[0].full_name, team: data[0].team_name } : { name: 'Unknown Driver' };
      } catch (error) {
        console.error(`Error fetching details for driver ${driverNumber}:`, error);
        return { name: 'Unknown Driver' };
      }
    }

    async function fetchRaceSpoilers(location, raceDate) {
      const raceSession = await getSession(location, "Race");
      const qualiSession = await getSession(location, "Qualifying");

      if (!raceSession) {
        return { error: `Race results not yet available for ${location}.` };
      }

      let poleSitter = { name: "N/A" };
      if (qualiSession) {
        try {
          const qualiResults = await fetch(`${API_BASE_URL}/session_result?session_key=${qualiSession.session_key}&position=1`).then(r => r.json());
          if (qualiResults.length > 0) {
            poleSitter = await getDriverDetails(qualiResults[0].driver_number);
          }
        } catch (e) { console.error("Error fetching qualifier:", e); }
      }

      let finishers = [];
      try {
        const raceResults = await fetch(`${API_BASE_URL}/session_result?session_key=${raceSession.session_key}`).then(r => r.json());
        const topThree = raceResults.filter(d => d.position >= 1 && d.position <= 3).sort((a, b) => a.position - b.position);

        for (const driver of topThree) {
          const details = await getDriverDetails(driver.driver_number);
          finishers.push({
            position: driver.position,
            name: details.name
          });
        }
      } catch (e) {
        console.error("Error fetching race finishers:", e);
        return { error: 'Could not fetch race finishers.' };
      }

      return { poleSitter, finishers };
    }


    async function updateSpoilers() {
      const selectedRaceName = raceNameSelect.value;
      if (!selectedRaceName) return;

      const raceData = raceSchedule.find(r => r.name === selectedRaceName);
      if (!raceData || !raceData.location) {
        spoilerResults.innerHTML = `<p class="text-amber-500">Spoiler data configuration missing for this event.</p>`;
        return;
      }

      spoilerResults.innerHTML = `<p>Loading spoiler data for ${selectedRaceName}...</p>`;

      const { poleSitter, finishers, error } = await fetchRaceSpoilers(raceData.location, raceData.raceDate);

      if (error) {
        spoilerResults.innerHTML = `<p class="text-red-500">${error}</p>`;
        return;
      }

      const medals = ['ü•á', 'ü•à', 'ü•â'];

      let resultsHtml = `<div class="space-y-4">`;
      resultsHtml += `
                <div>
                    <p class="text-sm text-gray-400">Top Qualifier</p>
                    <p class="text-lg font-bold text-red-400">${poleSitter.name}</p>
                </div>
            `;

      if (finishers.length > 0) {
        resultsHtml += `<div><p class="text-sm text-gray-400">Podium Finishers</p><ul class="space-y-2 mt-2">`;
        finishers.forEach(f => {
          resultsHtml += `
                        <li class="flex justify-between items-center bg-gray-900 p-2 rounded-md">
                            <div>
                                <span class="text-xl w-8 inline-block">${medals[f.position - 1]}</span>
                                <span class="font-semibold">${f.name}</span>
                            </div>
                        </li>`;
        });
        resultsHtml += `</ul></div>`;
      } else {
        resultsHtml += `<p>Podium data is not available.</p>`;
      }

      resultsHtml += `</div>`;
      spoilerResults.innerHTML = resultsHtml;
    }


    // --- Utility Functions ---

    function calculateCountdown(targetDate) {
      const now = new Date();
      const distance = targetDate.getTime() - now.getTime();

      if (distance < 0) {
        return null; // Race has passed
      }

      const days = Math.floor(distance / (1000 * 60 * 60 * 24));
      const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));

      return { days, hours, minutes };
    }

    function updateCountdown() {
      const now = new Date();
      let nextRace = null;

      // Sort races by date to ensure we find the correct next one
      const sortedRaces = [...raceSchedule].sort((a,b) => a.raceDate - b.raceDate);

      for (const race of sortedRaces) {
        if (race.raceDate > now) {
          nextRace = race;
          break;
        }
      }

      if (nextRace) {
        const countdown = calculateCountdown(nextRace.raceDate);
        document.getElementById('nextRaceName').textContent = nextRace.name;
        document.getElementById('nextRaceCircuit').textContent = nextRace.circuit;
        document.getElementById('countdownDays').textContent = countdown ? countdown.days : 0;
        document.getElementById('countdownHours').textContent = countdown ? countdown.hours : 0;
        document.getElementById('countdownMinutes').textContent = countdown ? countdown.minutes : 0;
      } else {
        document.getElementById('nextRaceName').textContent = "Season Finished";
        document.getElementById('nextRaceCircuit').textContent = "Check back for the next season!";
        document.getElementById('countdownDays').textContent = '0';
        document.getElementById('countdownHours').textContent = '0';
        document.getElementById('countdownMinutes').textContent = '0';
      }
    }

    function showAlert(message) {
      alertMessage.textContent = message;
      customAlert.classList.remove('hidden');
    }

    function closeAlert() {
      customAlert.classList.add('hidden');
    }

    // --- Dropdown Population Functions ---

    function populateRaceNames() {
      // Sort races by date before populating
      const sortedRaces = [...raceSchedule].sort((a,b) => a.raceDate - b.raceDate);
      const raceNames = sortedRaces.map(item => item.name);
      raceNameSelect.innerHTML = '<option value="" disabled selected>Select a Race Name</option>';
      raceNames.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        raceNameSelect.appendChild(option);
      });
    }

    function populateConstructors(selectedRace) {
      const filteredData = upgradeData.filter(item => item.RaceName === selectedRace);
      const constructors = [...new Set(filteredData.map(item => item.Constructor))];

      teamNamesSelect.innerHTML = '<option value="" disabled selected>Select a Team Name</option>';
      constructors.forEach(name => {
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        teamNamesSelect.appendChild(option);
      });
      teamDropdownContainer.classList.remove('hidden');
    }

    function populateUpdatedComponents(selectedRace, selectedConstructor) {
      upgradesNameSelect.innerHTML = '<option value="" disabled selected>Select an Upgrade</option>';
      if (selectedRace && selectedConstructor) {
        const filteredData = upgradeData.filter(
          item => item.RaceName === selectedRace && item.Constructor === selectedConstructor
        );
        const components = [...new Set(filteredData.map(item => item.UpdatedComponent))];
        components.forEach(name => {
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          upgradesNameSelect.appendChild(option);
        });
        upgradesDropdownContainer.classList.remove('hidden');
      } else {
        upgradesDropdownContainer.classList.add('hidden');
      }
      upgradesNameSelect.value = '';
      detailsCard.classList.add('hidden');
    }

    function displayDetails(selectedRace, selectedConstructor, selectedComponent) {
      spoilerSectionInCard.classList.add('hidden'); // Hide spoilers by default
      saveDetailBtn.classList.remove('hidden');

      if (selectedRace && selectedConstructor && selectedComponent) {
        const foundDetail = upgradeData.find(
          item => item.RaceName === selectedRace &&
            item.Constructor === selectedConstructor &&
            item.UpdatedComponent === selectedComponent
        );

        if (foundDetail) {
          detailPartName.textContent = foundDetail.UpdatedComponent;
          detailPrimaryReason.textContent = foundDetail.PrimaryReason;
          detailGeometricDifferences.textContent = foundDetail.GeometricDifferences;
          detailDescription.textContent = foundDetail.Description;
          detailsCard.classList.remove('hidden');

          const raceData = raceSchedule.find(r => r.name === selectedRace);
          if (raceData && raceData.raceDate < new Date()) {
            spoilerSectionInCard.classList.remove('hidden');
            // Ensure toggle is off and content is hidden by default
            spoilerToggle.checked = false;
            spoilerContent.classList.add('max-h-0');
            spoilerContent.classList.remove('max-h-[150rem]');
          }

        } else {
          detailsCard.classList.add('hidden');
        }
      } else {
        detailsCard.classList.add('hidden');
      }
    }

    // --- Event Handlers ---

    raceNameSelect.addEventListener('change', (e) => {
      const selectedRace = e.target.value;

      teamDropdownContainer.classList.add('hidden');
      upgradesDropdownContainer.classList.add('hidden');
      detailsCard.classList.add('hidden');
      spoilerSectionInCard.classList.add('hidden');

      const hasUpgradeData = upgradeData.some(item => item.RaceName === selectedRace);

      if (hasUpgradeData) {
        populateConstructors(selectedRace);
      } else { 
          const raceData = raceSchedule.find(r => r.name === selectedRace);
          if (raceData && raceData.raceDate < new Date()) {
            detailPartName.textContent = "N/A";
            detailPrimaryReason.textContent = "N/A";
            detailGeometricDifferences.textContent = "N/A";
            detailDescription.textContent = "No specific upgrade data available for this race.";
            detailsCard.classList.remove('hidden');
            saveDetailBtn.classList.add('hidden');
            spoilerSectionInCard.classList.remove('hidden');
            
            spoilerToggle.checked = false;
            spoilerContent.classList.add('max-h-0');
            spoilerContent.classList.remove('max-h-[150rem]');
          } else {
            saveDetailBtn.classList.remove('hidden');
          }
      }
    });

    teamNamesSelect.addEventListener('change', (e) => {
      const selectedConstructor = e.target.value;
      populateUpdatedComponents(raceNameSelect.value, selectedConstructor);
      displayDetails(raceNameSelect.value, selectedConstructor, upgradesNameSelect.value);
    });

    upgradesNameSelect.addEventListener('change', (e) => {
      const selectedComponent = e.target.value;
      displayDetails(raceNameSelect.value, teamNamesSelect.value, selectedComponent);
    });

    spoilerToggle.addEventListener('change', () => {
        if (spoilerToggle.checked) {
            spoilerContent.classList.remove('max-h-0');
            spoilerContent.classList.add('max-h-[150rem]');
            updateSpoilers();

            const selectedRaceName = raceNameSelect.value;
            const raceData = raceSchedule.find(r => r.name === selectedRaceName);
            
            if (typeof initializeComparisonForRace === 'function') {
                if (raceData && raceData.apiMeetingName) {
                    initializeComparisonForRace(raceData.apiMeetingName, raceData.name);
                } else {
                    initializeComparisonForRace(null, selectedRaceName);
                }
            }
        } else {
            spoilerContent.classList.add('max-h-0');
            spoilerContent.classList.remove('max-h-[150rem]');
        }
    });


    saveDetailBtn.addEventListener('click', () => {
      const currentDetails = {
        updatedComponent: detailPartName.textContent,
        primaryReason: detailPrimaryReason.textContent,
        geometricDifferences: detailGeometricDifferences.textContent,
        description: detailDescription.textContent,
        raceName: raceNameSelect.value,
        constructor: teamNamesSelect.value,
        id: Date.now()
      };

      if (!currentDetails.updatedComponent) {
        showAlert("Please select an upgrade to save details.");
        return;
      }

      const isDuplicate = savedDetailsList.some(item =>
        item.raceName === currentDetails.raceName &&
        item.constructor === currentDetails.constructor &&
        item.updatedComponent === currentDetails.updatedComponent
      );

      if (isDuplicate) {
        showAlert("This detail card is already saved!");
        return;
      }

      savedDetailsList.push(currentDetails);
      updateSavedCount();
      showAlert("Detail saved successfully to app memory!");

      raceNameSelect.value = '';
      teamDropdownContainer.classList.add('hidden');
      upgradesDropdownContainer.classList.add('hidden');
      detailsCard.classList.add('hidden');
      spoilerSectionInCard.classList.add('hidden');
    });

    showSavedDetailsBtn.addEventListener('click', () => {
      mainContent.classList.add('hidden');
      detailsCard.classList.add('hidden');
      spoilerSectionInCard.classList.add('hidden');
      savedDetailsView.classList.remove('hidden');
      renderSavedDetails();
    });

    backToMainBtn.addEventListener('click', () => {
      savedDetailsView.classList.add('hidden');
      mainContent.classList.remove('hidden');
      raceNameSelect.value = '';
      teamDropdownContainer.classList.add('hidden');
      upgradesDropdownContainer.classList.add('hidden');
      detailsCard.classList.add('hidden');
      spoilerSectionInCard.classList.add('hidden');
    });

    closeAlertBtn.addEventListener('click', closeAlert);

    function updateSavedCount() {
      savedCountSpan.textContent = savedDetailsList.length;
    }

    function renderSavedDetails() {
      savedDetailsListContainer.innerHTML = '';
      if (savedDetailsList.length === 0) {
        savedDetailsListContainer.innerHTML = '<p class="text-gray-400 text-center col-span-full">No details saved yet.</p>';
      } else {
        savedDetailsList.forEach(item => {
          const detailDiv = document.createElement('div');
          detailDiv.className = `bg-gray-700 border border-gray-600 p-5 rounded-lg shadow-md cursor-pointer
                                           hover:bg-gray-600 hover:scale-105 transition-all duration-200 ease-in-out relative`;
          detailDiv.innerHTML = `
                        <p class="font-semibold text-blue-300 text-lg mb-2">${item.updatedComponent}</p>
                        <p class="text-sm text-gray-300">Race: ${item.raceName}</p>
                        <p class="text-sm text-gray-300">Team: ${item.constructor}</p>
                        <p class="text-sm text-gray-400 mt-2 line-clamp-3">${item.description}</p>
                        <button class="remove-saved-detail-btn absolute top-2 right-2 bg-red-600 hover:bg-red-700 text-white rounded-full w-6 h-6 flex items-center justify-center text-xs font-bold" data-id="${item.id}">
                            X
                        </button>
                    `;
          detailDiv.addEventListener('click', () => handleViewSavedDetail(item));

          detailDiv.querySelector('.remove-saved-detail-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            handleRemoveSavedDetail(parseInt(e.target.dataset.id));
          });

          savedDetailsListContainer.appendChild(detailDiv);
        });
      }
    }

    function handleRemoveSavedDetail(idToRemove) {
      savedDetailsList = savedDetailsList.filter(item => item.id !== idToRemove);
      updateSavedCount();
      renderSavedDetails();
    }

    function handleViewSavedDetail(item) {
      savedDetailsView.classList.add('hidden');
      mainContent.classList.remove('hidden');

      spoilerSectionInCard.classList.add('hidden');
      if (spoilerToggle.checked) {
        spoilerToggle.checked = false;
        spoilerContent.classList.add('max-h-0');
        spoilerContent.classList.remove('max-h-[150rem]');
      }

      raceNameSelect.value = item.raceName;

      const hasUpgradeData = upgradeData.some(d => d.RaceName === item.raceName);
      if (hasUpgradeData) {
        populateConstructors(item.raceName);
        teamNamesSelect.value = item.constructor;
        populateUpdatedComponents(item.raceName, item.constructor);
        upgradesNameSelect.value = item.updatedComponent;
        displayDetails(item.raceName, item.constructor, item.updatedComponent);
      } else {
        teamDropdownContainer.classList.add('hidden');
        upgradesDropdownContainer.classList.add('hidden');
        detailsCard.classList.add('hidden');
      }
    }


    // --- Initial Setup on Window Load ---
    window.onload = function () {
      populateRaceNames();
      updateCountdown();
      setInterval(updateCountdown, 60000);
      updateSavedCount();
    };
  </script>
  <script>
    // --- START: INTEGRATED DRIVER COMPARISON SCRIPT ---
    (function() {
        const OPENF1_API_BASE_URL = 'https://api.openf1.org/v1';
        const mainContainer = document.querySelector('.session-container');
        const modal = document.getElementById('graphModal');
        const closeModalBtn = document.getElementById('closeModalBtn');

        let modalChartInstance = null;
        let lastChartData = null;
        const apiCache = new Map();

        function getCompareViewHTML() {
            return `
                <h2 class="text-xl font-bold text-white mb-2">Compare Driver Performance</h2>
                <div id="comparison-race-context" class="mb-4 p-3 bg-gray-900/50 rounded-lg border border-gray-700">
                    <p class="text-gray-400">For Race: <span id="comparison-race-name" class="font-bold text-white">Not Selected</span></p>
                </div>
                <div class="filters flex flex-col sm:flex-row gap-4 mb-4">
                    <label for="session-select-compare" class="text-lg font-bold text-blue-400 self-center">Session:</label>
                    <select id="session-select-compare" class="flex-grow bg-gray-900 text-gray-200 border border-gray-600 rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-blue-500"><option value="Race">Race</option><option value="Qualifying">Qualifying</option></select>
                </div>
                <div id="driver-selection" class="hidden flex-col sm:flex-row flex-wrap gap-4 items-center mb-6 bg-gray-900/50 p-4 rounded-lg border border-gray-700">
                    <select id="driver1-select" class="w-full sm:w-auto flex-1 bg-gray-900 text-gray-200 border border-gray-600 rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
                    <span class="text-gray-400 font-bold">vs</span>
                    <select id="driver2-select" class="w-full sm:w-auto flex-1 bg-gray-900 text-gray-200 border border-gray-600 rounded-md p-3 focus:outline-none focus:ring-2 focus:ring-blue-500"></select>
                    <button id="compare-btn" class="w-full sm:w-auto px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition duration-300 shadow-xl font-bold">Compare</button>
                </div>
                <div id="loader" class="text-center p-4 text-gray-300" style="display:none;"></div>
                <div id="error" class="text-center p-4 text-red-400 bg-red-900/40 border border-red-700 rounded-lg" style="display: none;"></div>
                <div id="results-content" style="display: none;">
                    <div id="fastest-lap-section" class="mb-8 p-6 bg-gray-900/50 rounded-lg border border-gray-700"></div>
                    <div id="compare-results" class="text-center mt-4">
                        <button id="showGraphBtn" class="hidden px-8 py-3 bg-gray-600 text-white rounded-lg hover:bg-gray-700 font-bold">Show Lap Gap Chart</button>
                    </div>
                </div>
            `;
        }

        async function populateDriverSelectForCompare() {
            showLoader('Loading driver data...');
            const meetingKey = mainContainer.dataset.meetingKey;
            const sessionType = document.getElementById('session-select-compare').value;
            const errorEl = document.getElementById('error');
            if (errorEl) errorEl.style.display = 'none';

            if (!meetingKey) {
                showError("No race event key found.");
                hideLoader();
                return;
            }

            const sessions = await fetchData(OPENF1_API_BASE_URL, `sessions?meeting_key=${meetingKey}`);
            if (!sessions) { hideLoader(); return; }
            
            const session = sessions.find(s => s.session_name === sessionType);
            if (!session) {
                showError(`'${sessionType}' session not found for this event.`);
                document.getElementById('driver-selection').style.display = 'none';
                hideLoader();
                return;
            }

            const drivers = await fetchData(OPENF1_API_BASE_URL, `drivers?session_key=${session.session_key}`);
            if (!drivers || drivers.length === 0) {
                showError(`No drivers found for the '${sessionType}' session.`);
                document.getElementById('driver-selection').style.display = 'none';
                hideLoader();
                return;
            }

            const d1Select = document.getElementById('driver1-select');
            const d2Select = document.getElementById('driver2-select');
            d1Select.innerHTML = '';
            d2Select.innerHTML = '';
            drivers.sort((a, b) => a.full_name.localeCompare(b.full_name)).forEach(d => {
                d1Select.innerHTML += `<option value="${d.driver_number}">${d.full_name}</option>`;
                d2Select.innerHTML += `<option value="${d.driver_number}">${d.full_name}</option>`;
            });

            if (d2Select.options.length > 1) {
                d2Select.selectedIndex = 1;
            }
            document.getElementById('driver-selection').style.display = 'flex';
            hideLoader();
        }

        async function displayCompareData() {
            showLoader('Fetching Session Data...');
            const meetingKey = mainContainer.dataset.meetingKey;
            const sessionType = document.getElementById('session-select-compare').value;
            const driver1 = document.getElementById('driver1-select').value;
            const driver2 = document.getElementById('driver2-select').value;
            
            if (driver1 === driver2) {
                showError("Please select two different drivers.");
                hideLoader();
                return;
            }

            const sessions = await fetchData(OPENF1_API_BASE_URL, `sessions?meeting_key=${meetingKey}`);
            if (!sessions) { hideLoader(); return; }

            const session = sessions.find(s => s.session_name === sessionType);
            if (!session) {
                showError("Could not find the selected session.");
                hideLoader();
                return;
            }
            
            const [laps, drivers] = await Promise.all([
                fetchData(OPENF1_API_BASE_URL, `laps?session_key=${session.session_key}`),
                fetchData(OPENF1_API_BASE_URL, `drivers?session_key=${session.session_key}`)
            ]);

            if (!laps || !drivers || laps.length === 0 || drivers.length === 0) {
                showError("Could not load lap or driver data for this session.");
                hideLoader();
                return;
            }

            const driverMap = new Map(drivers.map(d => [d.driver_number, d]));
            
            lastChartData = { laps, driverMap, driverNumbers: [parseInt(driver1), parseInt(driver2)] };
            
            const fastestLap = findFastestLap(laps, driverMap);
            renderFastestLap(fastestLap);

            document.getElementById('showGraphBtn').classList.remove('hidden');
            hideLoader();
        }

        function findFastestLap(laps, driverMap) {
            const validLaps = laps.filter(l => l.lap_duration);
            if (validLaps.length === 0) return null;
            const fastest = validLaps.reduce((f, c) => c.lap_duration < f.lap_duration ? c : f);
            fastest.driver_info = driverMap.get(fastest.driver_number);
            return fastest;
        }
        
        function renderFastestLap(lap) {
            const container = document.getElementById('fastest-lap-section');
            if (!lap || !lap.driver_info) {
                container.innerHTML = `<h2 class="text-lg font-bold text-white mb-2">Fastest Lap</h2><p class="text-gray-400">Data not available.</p>`;
                return;
            }
            const minutes = Math.floor(lap.lap_duration / 60);
            const seconds = (lap.lap_duration % 60).toFixed(3);
            const timeString = `${minutes}:${seconds.toString().padStart(6, '0')}`;
            container.innerHTML = `
                <h2 class="text-lg font-bold text-white mb-3">Fastest Lap of the Session</h2>
                <div class="fastest-lap-info text-center">
                    <div class="time text-4xl font-extrabold text-amber-400 tracking-wider">${timeString}</div>
                    <div class="driver text-xl font-semibold text-white mt-2">${lap.driver_info.full_name}</div>
                    <div class="lap text-md text-gray-400">on Lap ${lap.lap_number}</div>
                </div>`;
        }

        function renderLapGapChart(chart, canvasId) {
            if (chart) chart.destroy();

            const canvas = document.getElementById(canvasId);
            if (!canvas || !lastChartData) return null;

            const { laps, driverMap, driverNumbers } = lastChartData;
            const validLaps = laps.filter(l => l.lap_duration);
            if (validLaps.length === 0) {
                showError("No valid lap data to generate a chart.", true);
                return null;
            }
            
            const driver1Info = driverMap.get(driverNumbers[0]);
            const driver2Info = driverMap.get(driverNumbers[1]);

            const driver1Laps = new Map(validLaps.filter(l => l.driver_number === driverNumbers[0]).map(l => [l.lap_number, l.lap_duration]));
            const driver2Laps = new Map(validLaps.filter(l => l.driver_number === driverNumbers[1]).map(l => [l.lap_number, l.lap_duration]));

            const allLapNumbers = [...new Set([...driver1Laps.keys(), ...driver2Laps.keys()])].sort((a, b) => a - b);

            const gapData = [];
            const backgroundColors = [];
            
            const color1 = `#${driver1Info.team_colour || '999999'}`;
            const color2 = `#${driver2Info.team_colour || 'CCCCCC'}`;

            for (const lapNum of allLapNumbers) {
                const lap1Time = driver1Laps.get(lapNum);
                const lap2Time = driver2Laps.get(lapNum);

                if (lap1Time && lap2Time) {
                    const gap = lap1Time - lap2Time;
                    gapData.push(gap);
                    backgroundColors.push(gap <= 0 ? color1 : color2);
                } else {
                    gapData.push(null);
                    backgroundColors.push('transparent');
                }
            }
            
            return new Chart(canvas.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: allLapNumbers,
                    datasets: [{
                        label: 'Gap (s)',
                        data: gapData,
                        backgroundColor: backgroundColors,
                        borderColor: backgroundColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: `Lap Time Gap: ${driver1Info.full_name} vs. ${driver2Info.full_name}`,
                            color: '#c9d1d9',
                            font: { size: 16 }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const gapInSeconds = context.parsed.y;
                                    if (gapInSeconds === null) return 'No comparable lap time';
                                    
                                    const gapInMilliseconds = Math.abs(gapInSeconds * 1000);
                                    const formattedSeconds = Math.abs(gapInSeconds).toFixed(3);

                                    if (gapInSeconds <= 0) {
                                        return `${driver1Info.full_name} was faster by: ${formattedSeconds}s (${gapInMilliseconds.toFixed(0)}ms)`;
                                    } else {
                                        return `${driver1Info.full_name} was slower by: ${formattedSeconds}s (${gapInMilliseconds.toFixed(0)}ms)`;
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: 'Lap Number', color: '#8b949e' }, 
                            ticks: { color: '#8b949e' },
                            grid: { color: '#374151' }
                        },
                        y: { 
                            title: { display: true, text: `Gap to ${driver2Info.full_name} (s)`, color: '#8b949e' }, 
                            ticks: { color: '#8b949e' },
                            grid: { color: '#374151' }
                        }
                    }
                }
            });
        }

        async function fetchData(baseUrl, endpoint) {
            const url = `${baseUrl}/${endpoint}`;
            if (apiCache.has(url)) {
                return apiCache.get(url);
            }
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`API Error: ${response.status} for ${url}`);
                const data = await response.json();
                apiCache.set(url, data);
                return data;
            } catch (error) {
                showError(error.message);
                return null;
            }
        }
        
        function showLoader(message) {
            const loader = document.getElementById('loader');
            if (loader) {
                loader.textContent = message;
                loader.style.display = 'block';
            }
            document.getElementById('results-content').style.display = 'none';
            const error = document.getElementById('error');
            if (error) error.style.display = 'none';
        }

        function hideLoader() {
            const loader = document.getElementById('loader');
            if (loader) loader.style.display = 'none';
            document.getElementById('results-content').style.display = 'block';
        }

        function showError(message, isSoftError = false) {
            const error = document.getElementById('error');
            if (error) {
                error.textContent = message;
                error.style.display = 'block';
            }
            const loader = document.getElementById('loader');
            if (loader) loader.style.display = 'none';
            if (!isSoftError) {
                document.getElementById('results-content').style.display = 'none';
            }
        }
        
        window.initializeComparisonForRace = async function(apiMeetingName, displayName) {
            mainContainer.innerHTML = getCompareViewHTML();
            const year = "2025"; 
            mainContainer.dataset.year = year;
            document.getElementById('comparison-race-name').textContent = displayName || 'N/A';
            
            document.getElementById('session-select-compare').addEventListener('change', populateDriverSelectForCompare);
            document.getElementById('compare-btn').addEventListener('click', displayCompareData);
            document.getElementById('showGraphBtn').addEventListener('click', () => {
                if (lastChartData) {
                    modal.style.display = 'flex';
                    setTimeout(() => {
                        modalChartInstance = renderLapGapChart(modalChartInstance, 'modalChartCanvas');
                    }, 50);
                }
            });
            
            if (!apiMeetingName) {
                showError(`API mapping not found for "${displayName}". Cannot fetch race data.`);
                return;
            }
            
            showLoader('Finding Race Data...');

            const meetings = await fetchData(OPENF1_API_BASE_URL, `meetings?year=${year}`);
            if (!meetings) {
                showError("Could not load race event data from API.");
                hideLoader();
                return;
            }

            let meeting = meetings.find(m => m.meeting_name === apiMeetingName);
            
            if (!meeting) {
                showError(`Could not find a matching event for "${apiMeetingName}" in the API.`);
                hideLoader();
                return;
            }

            mainContainer.dataset.meetingKey = meeting.meeting_key;
            await populateDriverSelectForCompare();
        }

        closeModalBtn.addEventListener('click', () => {
            modal.style.display = 'none';
            if (modalChartInstance) {
                modalChartInstance.destroy();
                modalChartInstance = null;
            }
        });

    })();
    // --- END: INTEGRATED DRIVER COMPARISON SCRIPT ---
  </script>
</body>

</html>
